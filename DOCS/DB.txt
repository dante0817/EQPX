unit EQPX_1;

interface

uses
  System.DateUtils, Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ComCtrls, Vcl.ExtCtrls, Vcl.StdCtrls,
  Vcl.WinXCalendars, Vcl.Grids, Vcl.Samples.Calendar, Vcl.Mask, StrUtils, Generics.Collections;

type
  TfrmMain = class(TForm)
    pnlMain: TPanel;
    Panel1: TPanel;
    pgMain: TPageControl;
    tsEQBulletin: TTabSheet;
    tsSettings: TTabSheet;
    grpMain: TGroupBox;
    lblProgramPath: TLabel;
    cdrvwEQ_events1: TCalendarView;
    tsATLAS: TTabSheet;
    tsSTATIONS: TTabSheet;
    sgSOEPD_stations: TStringGrid;
    btnStations: TButton;
    tsDB: TTabSheet;
    Panel2: TPanel;
    Panel3: TPanel;
    lvEQ_events: TListView;
    btnEQevents: TButton;
    Panel4: TPanel;
    gbxEQ_params: TGroupBox;
    ledEQ_datex: TLabeledEdit;
    ledEQ_timex: TLabeledEdit;
    ledEQ_Lat: TLabeledEdit;
    ledEQ_Lon: TLabeledEdit;
    ledEQ_Dep: TLabeledEdit;
    ledEQ_Mag: TLabeledEdit;
    btnExtract_DateTime: TButton;
    ledMag_max: TLabeledEdit;
    DB: TButton;
    Panel5: TPanel;
    ListAtlas_files: TButton;
    Filter_time: TButton;
    Extract_EQinfo: TButton;
    Filter_distance: TButton;
    Atlas: TButton;
    ledTime_cutoff: TLabeledEdit;
    Panel6: TPanel;
    mmoATLAS_files2: TMemo;
    mmoATLAS_files: TMemo;
    mmoATLAS_files_final: TMemo;
    Panel7: TPanel;
    sgAtlas_data: TStringGrid;
    sgAtlasData2: TStringGrid;
    sgAtlasData_Final: TStringGrid;
    Combine_AtlasPS: TButton;
    tsPhaseData: TTabSheet;
    Panel8: TPanel;
    Panel9: TPanel;
    sgPhaseData: TStringGrid;
    PhaseData_extract: TButton;
    sgPhaseData_Filter_Time: TStringGrid;
    PhaseData_Filter_Time: TButton;
    sgPhaseData_Filter_Distance: TStringGrid;
    PhaseData_Filter_Distance: TButton;
    PhaseData: TButton;
    Plot_1st: TButton;
    ConvertDateTime_format: TButton;
    CombineData: TButton;
    btnSetDateTimePicker: TButton;
    DateTimePicker_update: TButton;
    tsEQP: TTabSheet;
    pnl1: TPanel;
    pnl2: TPanel;
    pnl3: TPanel;
    GroupBox8: TGroupBox;
    ledMInimum_P: TLabeledEdit;
    ledMInimum_S: TLabeledEdit;
    ledError_Pmin: TLabeledEdit;
    ledError_Smin: TLabeledEdit;
    gbxEQP_data: TGroupBox;
    EQ_data: TButton;
    PLOT_DAT: TButton;
    PHILSTA_DAT: TButton;
    EQP_data: TButton;
    gbxPLOT: TGroupBox;
    PLOT_eq: TButton;
    ExtractResult_heading: TButton;
    Update_res_PS: TButton;
    Plot: TButton;
    Used_P_S: TButton;
    gbxRePlot: TGroupBox;
    AutoPlot1: TButton;
    RePlot: TButton;
    RePlot_orig: TButton;
    Plot_again: TButton;
    Panel11: TPanel;
    edtHighestP_STN: TEdit;
    edtHighestS_STN: TEdit;
    ledHighestP_rms: TLabeledEdit;
    ledHighestS_rms: TLabeledEdit;
    ledRMS: TLabeledEdit;
    edtRMSX: TEdit;
    ledLat: TLabeledEdit;
    ledLon: TLabeledEdit;
    ledDep: TLabeledEdit;
    cbxInitialPlot: TCheckBox;
    Button3: TButton;
    Panel10: TPanel;
    GroupBox18: TGroupBox;
    edtTotal_P: TEdit;
    edtUsed_P: TEdit;
    edtTotal_S: TEdit;
    edtUsed_S: TEdit;
    edtError_P: TEdit;
    edtError_S: TEdit;
    Panel12: TPanel;
    sgMainData: TStringGrid;
    mmoResult: TMemo;
    Highest_S: TButton;
    Highest_P: TButton;
    dtpEQDateTime: TDateTimePicker;
    dtpEQ_datetime_start_GMT: TDateTimePicker;
    ledMagnitude: TLabeledEdit;
    ledEQ_name: TLabeledEdit;
    pnl4: TPanel;
    Panel13: TPanel;
    gbxBulletin_dirs: TGroupBox;
    ledSolution_path: TLabeledEdit;
    ledBulletin_path: TLabeledEdit;
    ledBase_path: TLabeledEdit;
    ledDrive_default: TLabeledEdit;
    ledEQBulletin_temp: TLabeledEdit;
    ledEQBulletin_template: TLabeledEdit;
    ledEQMap_temp: TLabeledEdit;
    Panel14: TPanel;
    lblVersion: TLabel;
    Panel15: TPanel;
    Label2: TLabel;
    Label3: TLabel;
    GroupBox16: TGroupBox;
    lblQVP_distance: TLabel;
    lblCity_nearest: TLabel;
    lblTown_nearest: TLabel;
    lblFaultLine_nearest: TLabel;
    gbxMagnitude: TGroupBox;
    RemoveOutliers_mag: TButton;
    Magnitude: TButton;
    procedure btnEQeventsClick(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure cdrvwEQ_events1Change(Sender: TObject);
    procedure ListAtlas_filesClick(Sender: TObject);
    procedure btnExtract_DateTimeClick(Sender: TObject);
    procedure Filter_timeClick(Sender: TObject);
    procedure DBClick(Sender: TObject);
    procedure Extract_EQinfoClick(Sender: TObject);
    procedure btnStationsClick(Sender: TObject);
    procedure Filter_distanceClick(Sender: TObject);
    procedure AtlasClick(Sender: TObject);
    procedure Combine_AtlasPSClick(Sender: TObject);
    procedure PhaseData_extractClick(Sender: TObject);
    procedure PhaseData_Filter_TimeClick(Sender: TObject);
    procedure PhaseData_Filter_DistanceClick(Sender: TObject);
    procedure PhaseDataClick(Sender: TObject);
    procedure Plot_1stClick(Sender: TObject);
    procedure CombineDataClick(Sender: TObject);
    procedure ConvertDateTime_formatClick(Sender: TObject);
    procedure btnSetDateTimePickerClick(Sender: TObject);
    procedure DateTimePicker_updateClick(Sender: TObject);
    procedure EQ_dataClick(Sender: TObject);
    procedure PLOT_DATClick(Sender: TObject);
    procedure PHILSTA_DATClick(Sender: TObject);
    procedure EQP_dataClick(Sender: TObject);
    procedure PLOT_eqClick(Sender: TObject);
    procedure ExtractResult_headingClick(Sender: TObject);
    procedure Update_res_PSClick(Sender: TObject);
    procedure Highest_SClick(Sender: TObject);
    procedure Highest_PClick(Sender: TObject);
    procedure PlotClick(Sender: TObject);
    procedure Used_P_SClick(Sender: TObject);
    procedure RePlotClick(Sender: TObject);
    procedure AutoPlot1Click(Sender: TObject);
    procedure Plot_againClick(Sender: TObject);
    procedure RePlot_origClick(Sender: TObject);
    procedure MagnitudeClick(Sender: TObject);
    procedure RemoveOutliers_magClick(Sender: TObject);

  private
    { Private declarations }
  public
    { Public declarations }
  end;

var
  frmMain: TfrmMain;

implementation

{$R *.dfm}

uses UTILS_DB, UTILS_fileIO, UTILS_settings, UTILS_DateTime, UTILS_ATLAS,
  UTILS_stations, UTILS_PhaseData, UTILS_CombineData, EQPlotter_data, UTILS,
  EQPlot, UTILS2, UTILS_Math;

procedure TfrmMain.CombineDataClick(Sender: TObject);
begin
  CombineAndUpdateAtlasData(sgPhaseData_Filter_Distance, sgAtlasData_Final);
end;

procedure TfrmMain.Combine_AtlasPSClick(Sender: TObject);
begin
  UTILS_ATLAS.CombineAtlasPS(sgAtlasData2, sgAtlasData_final);
end;

procedure TfrmMain.ConvertDateTime_formatClick(Sender: TObject);
var
  Row: Integer;
  TimeStr, FormattedDateTime: string;
begin
  // Loop through all rows, starting from row 1 (assuming row 0 is the header)
  for Row := 1 to sgPhaseData_Filter_Distance.RowCount - 1 do
  begin
    // Process column 3 (P arrival time)
    TimeStr := sgPhaseData_Filter_Distance.Cells[3, Row];
    if Trim(TimeStr) <> '' then
    begin
      try
        FormattedDateTime := ConvertTimeWithDate(TimeStr, ledEQ_datex);
//        FormattedDateTime := ConvertTimeWithDate(TimeStr, ledEQ_datex);
        FormattedDateTime := Copy(FormattedDateTime, 1, Length(FormattedDateTime));
        sgPhaseData_Filter_Distance.Cells[3, Row] := FormattedDateTime;
      except
        on E: Exception do
          ShowMessage('Error on row ' + IntToStr(Row) + ' in column 3: ' + E.Message);
      end;
    end;

    // Process column 5 (S arrival time)
    TimeStr := sgPhaseData_Filter_Distance.Cells[5, Row];
    if Trim(TimeStr) <> '' then
    begin
      try
        FormattedDateTime := ConvertTimeWithDate(TimeStr, ledEQ_datex);
        // Drop the third decimal place if present
        FormattedDateTime := Copy(FormattedDateTime, 1, Length(FormattedDateTime));
        sgPhaseData_Filter_Distance.Cells[5, Row] := FormattedDateTime;
      except
        on E: Exception do
          ShowMessage('Error on row ' + IntToStr(Row) + ' in column 5: ' + E.Message);
      end;
    end;
  end;

  // Optional: Display a message when the conversion is complete
//  ShowMessage('DateTime conversion completed.');
end;

procedure TfrmMain.btnEQeventsClick(Sender: TObject);
var
  Year, Month, Day: Word;
  MaxMagnitude: Double;
begin
  Year := 2020;
  Month := 01;
  Day   := 02;

  // Get the maximum magnitude from the LabeledEdit
  MaxMagnitude := StrToFloat(ledMag_max.Text);

  // Set up the ListView with columns using the procedure from UTILS_settings
  UTILS_settings.SetupListView(lvEQ_events);

  // Pass the year, month, day, and max magnitude to the procedure
  BrowseEarthquakeData(Year, Month, Day, lvEQ_events, lblProgramPath.Caption, MaxMagnitude);
end;

procedure TfrmMain.EQP_dataClick(Sender: TObject);
begin
  EQ_dataClick(nil);
  PLOT_DATClick(nil);
  PHILSTA_DATClick(nil);
end;

procedure TfrmMain.Filter_timeClick(Sender: TObject);
var
  DateStr: string;
  TimeStr: string;
  CutoffMin : integer;
begin
  // Get the date and time from the labeled edit controls
  DateStr := ledEQ_datex.Text;  // Assuming 'ledEQ_datex' is where the date is entered
  TimeStr := ledEQ_timex.Text;  // Assuming 'ledEQ_timex' is where the time is entered
  CutoffMin := StrToInt(ledTime_cutoff.Text);

  // Call the extraction procedure, passing the memo, date, time, and grid
  UTILS_ATLAS.Filter_Time(mmoATLAS_files, DateStr, TimeStr, CutoffMin, mmoATLAS_files2);
end;

procedure TfrmMain.Filter_distanceClick(Sender: TObject);
var
  eqMag: Single;
  Cutoff_Distance: Double;
begin
  // Retrieve the earthquake magnitude from the labeled edit
  eqMag := StrToFloat(ledEQ_Mag.Text);

  // Determine the cutoff distance based on the magnitude
  if (eqMag >= 3.5) and (eqMag <= 3.9) then
    Cutoff_Distance := 300
  else if (eqMag >= 3.0) and (eqMag <= 3.4) then
    Cutoff_Distance := 200
  else if (eqMag >= 2.5) and (eqMag <= 2.9) then
    Cutoff_Distance := 100
  else if (eqMag < 2.5) then
    Cutoff_Distance := 50;

  // Call the ComputeHypocentralDistance procedure with the calculated cutoff distance
  UTILS_ATLAS.FilterDistance(sgAtlas_data, sgSOEPD_stations, sgAtlasData2,
                  ledEQ_Lat, ledEQ_Lon, ledEQ_Dep, ledEQ_Mag, Cutoff_Distance);
end;

procedure TfrmMain.ExtractResult_headingClick(Sender: TObject);
begin
  EQPlot.ExtractResult_hdg(Trim(frmMain.mmoResult.Lines[2]));
end;

procedure TfrmMain.btnExtract_DateTimeClick(Sender: TObject);
begin
//  UTILS_DateTime.ExtractCheckedDateTime(lvEQ_events, ledEQ_datex, ledEQ_timex);

  UTILS_DateTime.ExtractCheckedDateTime(lvEQ_events, ledEQ_datex, ledEQ_timex, ledEQ_Mag, ledEQ_Lat, ledEQ_Lon, ledEQ_Dep);
end;

procedure TfrmMain.Extract_EQinfoClick(Sender: TObject);
begin
  UTILS_ATLAS.ExtractSelectedAtlasParametersToGrid(mmoATLAS_files2, sgATLAS_data);
end;

procedure TfrmMain.ListAtlas_filesClick(Sender: TObject);
begin
  UTILS_fileIO.ListAtlasDataFilesInMemo(ledEQ_datex.Text, ledEQ_timex.Text);
end;

procedure TfrmMain.MagnitudeClick(Sender: TObject);
begin
  UTILS_Math.Magnitude_duration;
end;

procedure TfrmMain.Plot_1stClick(Sender: TObject);
begin
  DBClick(nil);
  AtlasClick(nil);

  PhaseDataClick(nil);
  EQP_dataClick(nil);

  PLOTClick(nil);

//  UTILS.CountGreaterEqualOne('P'); // Count the values greater than or equal to 1.0 for 'P'
//  UTILS.CountGreaterEqualOne('S'); // Count the values greater than or equal to 1.0 for 'S'

end;

procedure TfrmMain.PhaseDataClick(Sender: TObject);
begin
  PhaseData_extractClick(nil);
  PhaseData_Filter_TimeClick(nil);
  PhaseData_Filter_DistanceClick(nil);

  ConvertDateTime_formatClick(nil);
  CombineDataClick(nil);
  DateTimePicker_updateClick(nil);
end;

procedure TfrmMain.PhaseData_extractClick(Sender: TObject);
var
  EQDate: TDateTime;
  CSVFilePath, ProgramPath: string;
begin
  EQDate := ISO8601ToDate(ledEQ_datex.Text);
  ProgramPath := lblProgramPath.Caption;  // Path from lblProgramPath
  // Call the conversion procedure
  ConvertExcelToCSV(EQDate, ProgramPath);
  CSVFilePath := IncludeTrailingPathDelimiter(ProgramPath) + 'TEMP\temp.csv';

  // Load the CSV data into the TStringGrid (sgPhaseData)
  LoadCSVToGrid(CSVFilePath, sgPhaseData);
 end;

procedure TfrmMain.PhaseData_Filter_DistanceClick(Sender: TObject);
var
  eqMag: Single;
  Cutoff_Distance: Double;
begin
  // Retrieve the earthquake magnitude from the labeled edit
  eqMag := StrToFloat(ledEQ_Mag.Text);

  // Determine the cutoff distance based on the magnitude
  if (eqMag >= 3.5) and (eqMag <= 3.9) then
    Cutoff_Distance := 300
  else if (eqMag >= 3.0) and (eqMag <= 3.4) then
    Cutoff_Distance := 200
  else if (eqMag >= 2.5) and (eqMag <= 2.9) then
    Cutoff_Distance := 100
  else if (eqMag < 2.5) then
    Cutoff_Distance := 50;

  // Now filter sgPhaseData2 by distance and save the result to sgPhaseData_Filter_Distance
  UTILS_PhaseData.PhaseData_Filter_Distance(sgPhaseData_Filter_Time, sgSOEPD_stations, sgPhaseData_Filter_Distance,
                  ledEQ_Lat, ledEQ_Lon, ledEQ_Dep, ledEQ_Mag, Cutoff_Distance);
end;

procedure TfrmMain.PhaseData_Filter_TimeClick(Sender: TObject);
var
  DateStr, TimeStr: string;
  CutoffMin: Integer;
begin
  // Get the date and time from the labeled edit controls
  DateStr := ledEQ_datex.Text;
  TimeStr := ledEQ_timex.Text;
  CutoffMin := StrToInt(ledTime_cutoff.Text);  // Convert cutoff minutes to integer

  // Call the extraction procedure, passing both grids, date, time, and cutoff
  UTILS_PhaseData.PhaseData_Filter_Time2(sgPhaseData, sgPhaseData_Filter_Time, DateStr, TimeStr, CutoffMin);
end;

procedure TfrmMain.PHILSTA_DATClick(Sender: TObject);
begin
  EQPlotter_data.PHILSTA_dat('PHILSTA.DAT', frmMain.lblProgramPath.Caption);
end;

procedure TfrmMain.PLOT_DATClick(Sender: TObject);
begin
  EQPlotter_data.PLOT_dat('PLOT.DAT');
 end;

procedure TfrmMain.PLOT_eqClick(Sender: TObject);
var
  s : string;
  i, j, iNumS : integer;
begin
  frmMain.mmoResult.Lines.Clear;

  s := frmMain.lblProgramPath.Caption + 'PLOTTER\PLOTTER1a.EXE';

  ChDir(frmMain.lblProgramPath.Caption + 'PLOTTER');

//  Utils.ExecProgram(s,'WAIT', SW_Minimize);
  UTILS.ExecProgram(s,'WAIT', SW_Minimize);

  frmMain.mmoResult.Lines.LoadFromFile(frmMain.lblProgramPath.Caption + 'PLOTTER\PLOT.OUT');

//  ExtractResultClick(nil);

  ChDir(frmMain.lblProgramPath.Caption);
end;

procedure TfrmMain.RemoveOutliers_magClick(Sender: TObject);
begin
  RemoveOutliers_magnitude(frmMain.sgMainData, 1, frmMain.sgMainData.RowCount - 1);
end;

procedure TfrmMain.RePlotClick(Sender: TObject);
begin
//  if not UTILS2.AreTotalsValid then exit;

  EQPlot.MainReplot;
end;

procedure TfrmMain.RePlot_origClick(Sender: TObject);
begin
  EQPlot.Replot_orig;
end;

procedure TfrmMain.btnSetDateTimePickerClick(Sender: TObject);
begin
  SetDateTimePickerFromLabeledEdits(ledEQ_datex, ledEQ_timex, dtpEQ_datetime_start_GMT);
end;

procedure TfrmMain.btnStationsClick(Sender: TObject);
var
  DatabasePath: string;
begin
  // Build the full path to the SQLite database
  DatabasePath := lblProgramPath.Caption + 'DB\SOEPD.sdb';
  // Load stations data into the TStringGrid
  LoadStationsToGrid(sgSOEPD_stations, DatabasePath);
end;

procedure TfrmMain.PlotClick(Sender: TObject);
begin
  PLOT_eqClick(nil);
  ExtractResult_headingClick(nil);
  Update_res_PSClick(nil);

  Used_P_SClick(nil);

//  Highest_SClick(nil);
//  Highest_PClick(nil);
end;

procedure TfrmMain.Plot_againClick(Sender: TObject);
var i : integer;
begin
    for i := 1 to 3 do begin
      PLOT_datClick(nil);
      PHILSTA_datClick(nil);

      PlotClick(nil);

//      ExtractResult_headingClick(nil);
//      Update_res_PSClick(nil);
//      Used_P_SClick(nil);
    end;

  frmMain.edtError_P.Text := IntToStr(UTILS.CountGreaterEqualOne('P')); // Count the values greater than or equal to 1.0 for 'P'
  frmMain.edtError_S.Text := IntToStr(UTILS.CountGreaterEqualOne('S')); // Count the values greater than or equal to 1.0 for 'S'
end;

procedure TfrmMain.DateTimePicker_updateClick(Sender: TObject);
begin
  UpdateDateTimePickerFromGrid;
end;

procedure TfrmMain.DBClick(Sender: TObject);
begin
  btnEQeventsClick(nil);
  btnExtract_DateTimeClick(nil);

  btnSetDateTimePickerClick(nil);
end;

procedure TfrmMain.EQ_dataClick(Sender: TObject);
begin
  EQPlotter_data.EQData(sgMainData);
end;

procedure TfrmMain.AutoPlot1Click(Sender: TObject);
begin
    Plot_1stClick(nil);
    RePlotClick(nil);

    RePlotClick(nil);

//    Replot_origClick(nil);
//    Quality_checkClick(nil);
end;

procedure TfrmMain.AtlasClick(Sender: TObject);
begin
  ListAtlas_filesClick(nil);
  Filter_timeClick(nil);
  Extract_EQinfoClick(nil);

  Filter_distanceClick(nil);
  Combine_AtlasPSClick(nil);
end;

procedure TfrmMain.cdrvwEQ_events1Change(Sender: TObject);
var
  SelectedDate: TDateTime;
  Year, Month, Day: Word;
  MaxMagnitude: Double;
begin
  // Get the selected date from the TCalendarView
  SelectedDate := cdrvwEQ_events1.Date;

  // Extract year, month, and day as integers
  DecodeDate(SelectedDate, Year, Month, Day);

  // Get the maximum magnitude from the LabeledEdit
  MaxMagnitude := StrToFloat(ledMag_max.Text);

  // Clear previous rows (except for the header)
//  sgEQ_events.RowCount := 1;

  // Pass the year, month, day, and max magnitude to the procedure
//  BrowseEarthquakeData(Year, Month, Day, sgEQ_events, lblProgramPath.Caption, MaxMagnitude);
  BrowseEarthquakeData(Year, Month, Day, lvEQ_events, lblProgramPath.Caption, MaxMagnitude);
end;

procedure TfrmMain.FormCreate(Sender: TObject);
begin
  dtpEQDateTime.Format := 'yyyy-MM-dd HH:mm:ss';
  lblProgramPath.Caption := ExtractFilePath(Application.ExeName);

  cdrvwEQ_events1.OnChange := cdrvwEQ_events1Change;

  btnStationsClick(nil);
end;

procedure TfrmMain.Highest_PClick(Sender: TObject);
var row : integer;
begin
  row := EQPlot.Highest_PS('P'); // For the first case (P)
  if (row > 0) and (Abs(StrToFloatDef(frmMain.sgMainData.Cells[2, row], 0)) >= 1.0) then
    frmMain.sgMainData.Cells[3, row] := '*';
end;

procedure TfrmMain.Highest_SClick(Sender: TObject);
var row : integer;
begin
  row := EQPlot.Highest_PS('S'); // For the first case (S)
  if (row > 0) and (Abs(StrToFloatDef(frmMain.sgMainData.Cells[5, row], 0)) >= 1) then
    frmMain.sgMainData.Cells[6, row] := '*';
end;

procedure TfrmMain.Update_res_PSClick(Sender: TObject);
begin
  EQPlot.Update_resPS_delta;
end;

procedure TfrmMain.Used_P_SClick(Sender: TObject);
begin
  UTILS.CountUsed_PS;
end;

end.

unit UTILS_DateTime;

interface

uses
  StrUtils, Dialogs , SysUtils , Vcl.Mask, Vcl.ExtCtrls, ComCtrls, StdCtrls; // Include necessary units for TListView and TLabeledEdit

function ExtractDateTime_heading(sDateTime : string) : string;

function ExtractDateTime(sDateTime: string): TDateTime;
procedure UpdateDateTimePickerFromGrid;

procedure SetDateTimePickerFromLabeledEdits(ledEQ_datex, ledEQ_timex: TLabeledEdit; dtpEQDateTime: TDateTimePicker);

function ConvertTimeWithDate(const TimeStr: string; ledEQ_datex: TLabeledEdit): string;

procedure ConvertDateTime_format(DateTime_format1 : string);
// Declare the ExtractCheckedDateTime procedure

procedure ExtractCheckedDateTime(ListView: TListView;
  ledEQ_datex, ledEQ_timex, ledEQ_Mag, ledEQ_Lat, ledEQ_Lon, ledEQ_Dep: TLabeledEdit);

implementation

uses EQPX_1;


function ExtractDateTime_heading(sDateTime : string) : string;
var
  wX, wYr, wMon, wDay, wHr, wMin, wSec, wMSec : Word;
  s, x : string;
  OldShortDateFormat: string;
  OldDateSeparator: Char;
  dt: TDateTime;
  fs: TFormatSettings;
  i : integer;
begin
  fs := TFormatSettings.Create;
  fs.DateSeparator := '-';

  fs.ShortDateFormat := 'yyyy-MM-dd';
  fs.LongTimeFormat := 'hh:mm:ss.zzzz';

  dt := StrToDateTime(sDateTime, fs);
  DecodeDate(dt, wYr, wMon, wDay);
  DecodeTime(dt, wHr, wMin, wSec, wMSec);

//  if wMin < 10 then begin
//    wHr := wHr - 1;
//    wMin := wMin + 60;
//  end;

//    Result := Format('%.*d%.*d%.*d%.*d%.*d %.1f', [2, wMon, 2, wDay, 2, wYr mod 100, 2, wHr, 2, wMin, StrToFloat(frmMain.sgAtlasPick.Cells[7, 2])]);

    s := FormatFloat('00', wMon); // month
    s := s + FormatFloat('00', wDay); // day
    s := s + FormatFloat('00', StrToInt(RightStr(IntToStr(wYr), 2))); // year

    s := s + FormatFloat('00', wHr); // hour
    s := s + FormatFloat('00', wMin); // minute
    x := RightStr(sDateTime, 5);
//    s := s +' '+ FormatFloat('00.0', StrToFloat(frmMain.sgAtlasPick.Cells[7,2])); // second
    s := s +' '+ FormatFloat('00.0', StrToFloat(x)); // second
    Result := s;
end;

function ExtractDateTime(sDateTime: string): TDateTime;
var
  fs: TFormatSettings;
begin
  fs := TFormatSettings.Create;
  fs.DateSeparator := '-';
  fs.TimeSeparator := ':';
  fs.ShortDateFormat := 'yyyy-MM-dd';
  fs.LongTimeFormat := 'hh:mm:ss.zzzz';  // Supports fractional seconds

  // Convert the string to a TDateTime using the specified format settings
  try
    Result := StrToDateTime(sDateTime, fs);
  except
    on E: Exception do
    begin
      raise Exception.Create('Error parsing DateTime: ' + E.Message);
    end;
  end;
end;

procedure UpdateDateTimePickerFromGrid;
var
  DateTimeValue: TDateTime;
begin
  try
    // Extract the TDateTime from the grid cell (sgAtlasData_Final.Cells[4,1])
    DateTimeValue := ExtractDateTime(frmMain.sgAtlasData_Final.Cells[4, 1]);

    // Update the DateTimePicker with the extracted value
    frmMain.dtpEQDateTime.DateTime := DateTimeValue;

//    ShowMessage('DateTimePicker updated to: ' + DateTimeToStr(DateTimeValue));
  except
    on E: Exception do
    begin
      ShowMessage('Failed to update DateTimePicker: ' + E.Message);
    end;
  end;
end;

procedure SetDateTimePickerFromLabeledEdits(ledEQ_datex, ledEQ_timex: TLabeledEdit; dtpEQDateTime: TDateTimePicker);
var
  CombinedDateTime: TDateTime;
  DateStr, TimeStr: string;
  DateValue, TimeValue: TDateTime;
  FormatSettings: TFormatSettings;
begin
  // Set up custom format settings
  FormatSettings := TFormatSettings.Create;
  FormatSettings.DateSeparator := '-';
  FormatSettings.ShortDateFormat := 'yyyy-mm-dd';
  FormatSettings.TimeSeparator := ':';
  FormatSettings.ShortTimeFormat := 'hh:nn';

  // Get values from labeled edits
  DateStr := Trim(ledEQ_datex.Text);  // Example: '2024-10-15'
  TimeStr := Trim(ledEQ_timex.Text);  // Example: '14:30'

  try
    // Convert date and time strings to TDateTime
    DateValue := StrToDate(DateStr, FormatSettings);
    TimeValue := StrToTime(TimeStr, FormatSettings);

    // Combine the date and time
    CombinedDateTime := DateValue + Frac(TimeValue);

    // Set the value of the DateTimePicker
    dtpEQDateTime.DateTime := CombinedDateTime;
  except
    on E: Exception do
      ShowMessage('Error setting DateTimePicker: ' + E.Message);
  end;
end;

function ConvertTimeWithDate(const TimeStr: string; ledEQ_datex: TLabeledEdit): string;
var
  Hour, Minute, Second, MSec: string;
  DatePart, DateTimeResult: TDateTime;
  FormatSettings: TFormatSettings;
  S : string;
  f,g : Single;
begin
  if Length(TimeStr) < 8 then
    raise Exception.Create('Invalid time format. Expected hhmmss.ss');

  // Extract hour, minute, second, and millisecond parts
  Hour := Copy(TimeStr, 1, 2);
  Minute := Copy(TimeStr, 3, 2);
  Second := Copy(TimeStr, 5, 2);
  MSec := Copy(TimeStr, 8, Length(TimeStr) - 7);

  Result := ledEQ_datex.Text +' '+ Hour +':'+ Minute +':'+ Second +'.'+ MSec;
end;

procedure ConvertDateTime_format(DateTime_format1 : string);
var
  OriginalDateTime: TDateTime;
  OriginalValue: Double;
  FormattedDateTime: string;
  FormattedValue: string;
begin
  // Example values
  OriginalDateTime := StrToDateTime(DateTime_format1);
  OriginalValue := 532.28; // Example value with leading zeros

  // Format the DateTime as 'yyyy-mm-dd hh:nn:ss'
  FormattedDateTime := FormatDateTime('yyyy-mm-dd hh:nn:ss', OriginalDateTime);

  // Format the floating number without leading zeros
  FormattedValue := FormatFloat('0.00', OriginalValue);

  // Output the results
  ShowMessage('Formatted DateTime: ' + FormattedDateTime);
  ShowMessage('Formatted Value: ' + FormattedValue);
end;

procedure ExtractCheckedDateTime(ListView: TListView;
  ledEQ_datex, ledEQ_timex, ledEQ_Mag, ledEQ_Lat, ledEQ_Lon, ledEQ_Dep: TLabeledEdit);
var
  i: Integer;
  DateValue, TimeValue, MagValue, LatValue, LonValue, DepValue: string;
begin
  // Iterate over all items in the ListView
//  for i := 0 to ListView.Items.Count - 1 do
  for i := 7 to ListView.Items.Count - 1 do
  begin
    // Check if the item is checked (selected)
    if ListView.Items[i].Checked then
    begin
      // Extract Date and Time from SubItems
      DateValue := ListView.Items[i].SubItems[0];  // Date is in the first SubItem
      TimeValue := ListView.Items[i].SubItems[1];  // Time is in the second SubItem

      // Extract Latitude, Longitude, and Depth from SubItems
      MagValue := ListView.Items[i].SubItems[2];   // Magnitude in the sixth SubItem
      LatValue := ListView.Items[i].SubItems[3];  // Latitude in the third SubItem
      LonValue := ListView.Items[i].SubItems[4];  // Longitude in the fourth SubItem
      DepValue := ListView.Items[i].SubItems[5];  // Depth in the fifth SubItem

      // Set the extracted Date and Time to the labeled edits
      ledEQ_datex.Text := DateValue;  // Set the date in ledEQ_datex
      ledEQ_timex.Text := Copy(TimeValue, 1, 5);  // Set the time (HH:MM format) in ledEQ_timex

      // Set the extracted Latitude, Longitude, and Depth to the respective labeled edits
      ledEQ_Mag.Text := MagValue;  // Set the magnitude in ledEQ_Mag
      ledEQ_Lat.Text := LatValue;  // Set the latitude in ledEQ_Lat
      ledEQ_Lon.Text := LonValue;  // Set the longitude in ledEQ_Lon
      ledEQ_Dep.Text := DepValue;  // Set the depth in ledEQ_Dep

      // Stop after the first checked item, if you only need one
      Break;
    end;
  end;
end;

end.

unit UTILS_DateTime;

interface

uses
  StrUtils, Dialogs , SysUtils , Vcl.Mask, Vcl.ExtCtrls, ComCtrls, StdCtrls; // Include necessary units for TListView and TLabeledEdit

function ExtractDateTime_heading(sDateTime : string) : string;

function ExtractDateTime(sDateTime: string): TDateTime;
procedure UpdateDateTimePickerFromGrid;

procedure SetDateTimePickerFromLabeledEdits(ledEQ_datex, ledEQ_timex: TLabeledEdit; dtpEQDateTime: TDateTimePicker);

function ConvertTimeWithDate(const TimeStr: string; ledEQ_datex: TLabeledEdit): string;

procedure ConvertDateTime_format(DateTime_format1 : string);
// Declare the ExtractCheckedDateTime procedure

procedure ExtractCheckedDateTime(ListView: TListView;
  ledEQ_datex, ledEQ_timex, ledEQ_Mag, ledEQ_Lat, ledEQ_Lon, ledEQ_Dep: TLabeledEdit);

implementation

uses EQPX_1;


function ExtractDateTime_heading(sDateTime : string) : string;
var
  wX, wYr, wMon, wDay, wHr, wMin, wSec, wMSec : Word;
  s, x : string;
  OldShortDateFormat: string;
  OldDateSeparator: Char;
  dt: TDateTime;
  fs: TFormatSettings;
  i : integer;
begin
  fs := TFormatSettings.Create;
  fs.DateSeparator := '-';

  fs.ShortDateFormat := 'yyyy-MM-dd';
  fs.LongTimeFormat := 'hh:mm:ss.zzzz';

  dt := StrToDateTime(sDateTime, fs);
  DecodeDate(dt, wYr, wMon, wDay);
  DecodeTime(dt, wHr, wMin, wSec, wMSec);

//  if wMin < 10 then begin
//    wHr := wHr - 1;
//    wMin := wMin + 60;
//  end;

//    Result := Format('%.*d%.*d%.*d%.*d%.*d %.1f', [2, wMon, 2, wDay, 2, wYr mod 100, 2, wHr, 2, wMin, StrToFloat(frmMain.sgAtlasPick.Cells[7, 2])]);

    s := FormatFloat('00', wMon); // month
    s := s + FormatFloat('00', wDay); // day
    s := s + FormatFloat('00', StrToInt(RightStr(IntToStr(wYr), 2))); // year

    s := s + FormatFloat('00', wHr); // hour
    s := s + FormatFloat('00', wMin); // minute
    x := RightStr(sDateTime, 5);
//    s := s +' '+ FormatFloat('00.0', StrToFloat(frmMain.sgAtlasPick.Cells[7,2])); // second
    s := s +' '+ FormatFloat('00.0', StrToFloat(x)); // second
    Result := s;
end;

function ExtractDateTime(sDateTime: string): TDateTime;
var
  fs: TFormatSettings;
begin
  fs := TFormatSettings.Create;
  fs.DateSeparator := '-';
  fs.TimeSeparator := ':';
  fs.ShortDateFormat := 'yyyy-MM-dd';
  fs.LongTimeFormat := 'hh:mm:ss.zzzz';  // Supports fractional seconds

  // Convert the string to a TDateTime using the specified format settings
  try
    Result := StrToDateTime(sDateTime, fs);
  except
    on E: Exception do
    begin
      raise Exception.Create('Error parsing DateTime: ' + E.Message);
    end;
  end;
end;

procedure UpdateDateTimePickerFromGrid;
var
  DateTimeValue: TDateTime;
begin
  try
    // Extract the TDateTime from the grid cell (sgAtlasData_Final.Cells[4,1])
    DateTimeValue := ExtractDateTime(frmMain.sgAtlasData_Final.Cells[4, 1]);

    // Update the DateTimePicker with the extracted value
    frmMain.dtpEQDateTime.DateTime := DateTimeValue;

//    ShowMessage('DateTimePicker updated to: ' + DateTimeToStr(DateTimeValue));
  except
    on E: Exception do
    begin
      ShowMessage('Failed to update DateTimePicker: ' + E.Message);
    end;
  end;
end;

procedure SetDateTimePickerFromLabeledEdits(ledEQ_datex, ledEQ_timex: TLabeledEdit; dtpEQDateTime: TDateTimePicker);
var
  CombinedDateTime: TDateTime;
  DateStr, TimeStr: string;
  DateValue, TimeValue: TDateTime;
  FormatSettings: TFormatSettings;
begin
  // Set up custom format settings
  FormatSettings := TFormatSettings.Create;
  FormatSettings.DateSeparator := '-';
  FormatSettings.ShortDateFormat := 'yyyy-mm-dd';
  FormatSettings.TimeSeparator := ':';
  FormatSettings.ShortTimeFormat := 'hh:nn';

  // Get values from labeled edits
  DateStr := Trim(ledEQ_datex.Text);  // Example: '2024-10-15'
  TimeStr := Trim(ledEQ_timex.Text);  // Example: '14:30'

  try
    // Convert date and time strings to TDateTime
    DateValue := StrToDate(DateStr, FormatSettings);
    TimeValue := StrToTime(TimeStr, FormatSettings);

    // Combine the date and time
    CombinedDateTime := DateValue + Frac(TimeValue);

    // Set the value of the DateTimePicker
    dtpEQDateTime.DateTime := CombinedDateTime;
  except
    on E: Exception do
      ShowMessage('Error setting DateTimePicker: ' + E.Message);
  end;
end;

function ConvertTimeWithDate(const TimeStr: string; ledEQ_datex: TLabeledEdit): string;
var
  Hour, Minute, Second, MSec: string;
  DatePart, DateTimeResult: TDateTime;
  FormatSettings: TFormatSettings;
  S : string;
  f,g : Single;
begin
  if Length(TimeStr) < 8 then
    raise Exception.Create('Invalid time format. Expected hhmmss.ss');

  // Extract hour, minute, second, and millisecond parts
  Hour := Copy(TimeStr, 1, 2);
  Minute := Copy(TimeStr, 3, 2);
  Second := Copy(TimeStr, 5, 2);
  MSec := Copy(TimeStr, 8, Length(TimeStr) - 7);

  Result := ledEQ_datex.Text +' '+ Hour +':'+ Minute +':'+ Second +'.'+ MSec;
end;

procedure ConvertDateTime_format(DateTime_format1 : string);
var
  OriginalDateTime: TDateTime;
  OriginalValue: Double;
  FormattedDateTime: string;
  FormattedValue: string;
begin
  // Example values
  OriginalDateTime := StrToDateTime(DateTime_format1);
  OriginalValue := 532.28; // Example value with leading zeros

  // Format the DateTime as 'yyyy-mm-dd hh:nn:ss'
  FormattedDateTime := FormatDateTime('yyyy-mm-dd hh:nn:ss', OriginalDateTime);

  // Format the floating number without leading zeros
  FormattedValue := FormatFloat('0.00', OriginalValue);

  // Output the results
  ShowMessage('Formatted DateTime: ' + FormattedDateTime);
  ShowMessage('Formatted Value: ' + FormattedValue);
end;

procedure ExtractCheckedDateTime(ListView: TListView;
  ledEQ_datex, ledEQ_timex, ledEQ_Mag, ledEQ_Lat, ledEQ_Lon, ledEQ_Dep: TLabeledEdit);
var
  i: Integer;
  DateValue, TimeValue, MagValue, LatValue, LonValue, DepValue: string;
begin
  // Iterate over all items in the ListView
//  for i := 0 to ListView.Items.Count - 1 do
  for i := 7 to ListView.Items.Count - 1 do
  begin
    // Check if the item is checked (selected)
    if ListView.Items[i].Checked then
    begin
      // Extract Date and Time from SubItems
      DateValue := ListView.Items[i].SubItems[0];  // Date is in the first SubItem
      TimeValue := ListView.Items[i].SubItems[1];  // Time is in the second SubItem

      // Extract Latitude, Longitude, and Depth from SubItems
      MagValue := ListView.Items[i].SubItems[2];   // Magnitude in the sixth SubItem
      LatValue := ListView.Items[i].SubItems[3];  // Latitude in the third SubItem
      LonValue := ListView.Items[i].SubItems[4];  // Longitude in the fourth SubItem
      DepValue := ListView.Items[i].SubItems[5];  // Depth in the fifth SubItem

      // Set the extracted Date and Time to the labeled edits
      ledEQ_datex.Text := DateValue;  // Set the date in ledEQ_datex
      ledEQ_timex.Text := Copy(TimeValue, 1, 5);  // Set the time (HH:MM format) in ledEQ_timex

      // Set the extracted Latitude, Longitude, and Depth to the respective labeled edits
      ledEQ_Mag.Text := MagValue;  // Set the magnitude in ledEQ_Mag
      ledEQ_Lat.Text := LatValue;  // Set the latitude in ledEQ_Lat
      ledEQ_Lon.Text := LonValue;  // Set the longitude in ledEQ_Lon
      ledEQ_Dep.Text := DepValue;  // Set the depth in ledEQ_Dep

      // Stop after the first checked item, if you only need one
      Break;
    end;
  end;
end;

end.

