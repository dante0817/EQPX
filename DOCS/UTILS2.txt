unit UTILS_Math;

interface

uses
  SysUtils, System.StrUtils, DateUtils, Math;

procedure Magnitude_duration;

function ComputeCoda(sDateTime_P, sDateTime_C: string): string;
function Haversine(lat1, lon1, lat2, lon2: Double): Double;

implementation

uses EQPX_1;

procedure Magnitude_duration;
var
  i: integer;
  Mag, MB, MS, sDelta, sDuration: Single;
begin
  // Iterate through the rows of sgMainData
  for i := 1 to frmMain.sgMainData.RowCount - 1 do
  begin
    // Skip the row if the "P" column contains an asterisk (*)
    if (Pos('*', frmMain.sgMainData.Cells[3, i]) > 0) or (frmMain.sgMainData.Cells[7, i] = '') then
      Continue;
    // Retrieve the sDelta and sDuration values from the corresponding columns
    sDelta := StrToFloat(frmMain.sgMainData.Cells[8, i]);
    sDuration := StrToFloat(frmMain.sgMainData.Cells[7, i]);
    // Calculate the magnitudes depending on the value of sDelta
    if sDelta > 4.5 then
      Mag := -3.68 + 3.24 * Log10(sDuration) + 9.07 * 0.0001 * sDelta * 111.1
    else
      Mag := -3.49 + 3.24 * Log10(sDuration);
    // Calculate MB and MS magnitudes
    MB := (sqr(Mag) * 0.01) + (Mag * 0.8) + 1.7;
    MS := (MB - 2.5) / 0.63;
    // Save the calculated values to column 9
    frmMain.sgMainData.Cells[9, i] := FormatFloat('0.00', Mag);
  end;
end;

function Haversine(lat1, lon1, lat2, lon2: Double): Double;
const
  R = 6371; // Earth's radius in kilometers
var
  dLat, dLon, a, c: Double;
begin
  dLat := DegToRad(lat2 - lat1);
  dLon := DegToRad(lon2 - lon1);

  a := Sin(dLat / 2) * Sin(dLat / 2) + Cos(DegToRad(lat1)) * Cos(DegToRad(lat2)) * Sin(dLon / 2) * Sin(dLon / 2);
  c := 2 * ArcTan2(Sqrt(a), Sqrt(1 - a));

  Result := R * c; // Distance in kilometers
end;

function ComputeCoda(sDateTime_P, sDateTime_C: string): string;
var
  yrP, monP, dayP: integer;
  yrC, monC, dayC: integer;
  dtDateTime_P, dtDate_P, dtTime_P: TDateTime;
  dtDateTime_C, dtDate_C, dtTime_C: TDateTime;
  s: string;
begin
  // Extract time and date from P phase
  s := Trim(Copy(sDateTime_P, 12, 8)); // Time part for P phase
  dtTime_P := StrToTime(s);

  yrP := StrToInt(LeftStr(sDateTime_P, 4));  // Year
  monP := StrToInt(Copy(sDateTime_P, 6, 2)); // Month
  dayP := StrToInt(Copy(sDateTime_P, 9, 2)); // Day
  dtDate_P := EncodeDate(yrP, monP, dayP);   // Date
  dtDateTime_P := dtDate_P + dtTime_P;       // Full DateTime for P phase

  // Extract time and date from Coda time
  s := Trim(Copy(sDateTime_C, 12, 8)); // Time part for Coda
  dtTime_C := StrToTime(s);

  yrC := StrToInt(LeftStr(sDateTime_C, 4));  // Year
  monC := StrToInt(Copy(sDateTime_C, 6, 2)); // Month
  dayC := StrToInt(Copy(sDateTime_C, 9, 2)); // Day
  dtDate_C := EncodeDate(yrC, monC, dayC);   // Date
  dtDateTime_C := dtDate_C + dtTime_C;       // Full DateTime for Coda

  // Calculate the seconds difference between P phase and Coda time
  Result := FloatToStr(SecondsBetween(dtDateTime_C, dtDateTime_P));
end;

end.

unit UTILS_stations;

interface

uses
  FireDAC.Comp.Client, Vcl.Grids;

procedure LoadStationsToGrid(sgSOEPD_stations: TStringGrid; const DBPath: string);

implementation

procedure LoadStationsToGrid(sgSOEPD_stations: TStringGrid; const DBPath: string);
var
  FDConnection: TFDConnection;
  FDQuery: TFDQuery;
  i, j: Integer;
begin
  // Initialize connection to SQLite DB
  FDConnection := TFDConnection.Create(nil);
  try
    FDConnection.DriverName := 'SQLite';
    FDConnection.Params.Database := DBPath; // Set the database path dynamically
    FDConnection.LoginPrompt := False;
    FDConnection.Connected := True;

    // Create query to select all data from stations
    FDQuery := TFDQuery.Create(nil);
    try
      FDQuery.Connection := FDConnection;

      // Set RowsetSize to fetch all rows at once
      FDQuery.FetchOptions.RowsetSize := -1;  // Fetch all rows

      // SQL query to fetch all stations
      FDQuery.SQL.Text := 'SELECT * FROM stations';
      FDQuery.Open;

      // Set up StringGrid column headers
      sgSOEPD_stations.RowCount := 1; // Initially, only header row
      sgSOEPD_stations.ColCount := FDQuery.FieldCount;

      // Set up column headers in the first row (row 0)
      for i := 0 to FDQuery.FieldCount - 1 do
      begin
        sgSOEPD_stations.Cells[i, 0] := FDQuery.Fields[i].FieldName; // Header
      end;

      // Populate StringGrid with data
      i := 1; // Start at row 1 since row 0 is header
      while not FDQuery.Eof do
      begin
        sgSOEPD_stations.RowCount := sgSOEPD_stations.RowCount + 1;  // Add a new row for each record
        for j := 0 to FDQuery.FieldCount - 1 do
        begin
          sgSOEPD_stations.Cells[j, i] := FDQuery.Fields[j].AsString;
        end;
        Inc(i);
        FDQuery.Next;
      end;

    finally
      FDQuery.Free;
    end;

  finally
    FDConnection.Free;
  end;
end;

end.

unit UTILS2;

interface

uses SysUtils, System.StrUtils, Grids, System.Generics.Collections;

procedure RemoveOutliers_magnitude(sgData: TStringGrid; startRow, endRow: Integer);

function Remaining_PS: Boolean;

function CheckValuesAndAddAsterisk_S(RMS_limit: Double): Boolean;
function CheckValuesAndAddAsterisk_P(RMS_limit: Double): Boolean;

function Highest_PS(P_S: Char) : Integer;

implementation

uses EQPX_1;

procedure RemoveOutliers_magnitude(sgData: TStringGrid; startRow, endRow: Integer);
var
  i, ctr: Integer;
  Mag, temp, fAveMag, fVariance, fStdDeviation, fStdDev1, fStdDev2: Single;
  MagValues: TList<Single>; // Declare a new variable for the list of Mag values
  validMagSum, validMagCount: Single;
begin
  validMagSum := 0;
  validMagCount := 0;

  // Create the list of Mag values
  MagValues := TList<Single>.Create;
  try
    // Fill the list with Mag values from the sgData, skipping empty cells
    for i := startRow to endRow do
    begin
      if Trim(sgData.Cells[9, i]) <> '' then // Check if the cell is not empty
      begin
        Mag := StrToFloat(sgData.Cells[9, i]);
        MagValues.Add(Mag);
      end;
    end;
    // Compute the mean
    ctr := 0;
    fAveMag := 0;
    for i := 0 to MagValues.Count - 1 do
    begin
      inc(ctr);
      fAveMag := fAveMag + MagValues[i];
    end;
    fAveMag := fAveMag / ctr;
    // Compute the variance
    fVariance := 0;
    for i := 0 to MagValues.Count - 1 do
    begin
      temp := Sqr(MagValues[i] - fAveMag);
      fVariance := fVariance + temp;
    end;
    fVariance := fVariance / ctr;
    // Compute the standard deviation
    fStdDeviation := Sqrt(fVariance);
    // Define the upper and lower boundaries for outliers
    fStdDev1 := fAveMag + fStdDeviation;
    fStdDev2 := fAveMag - fStdDeviation;
    // Write valid Mag values to column 10 and compute their average
    for i := startRow to endRow do
    begin
      if sgData.Cells[9, i] <> '' then // Skip empty cells
      begin
        Mag := StrToFloat(sgData.Cells[9, i]);
        if (Mag >= fStdDev2) and (Mag <= fStdDev1) then
        begin
          // Write the Mag value
          sgData.Cells[10, i] := FormatFloat('0.00', Mag);
          validMagSum := validMagSum + Mag;
          validMagCount := validMagCount + 1;
        end;
      end;
    end;

  finally
    MagValues.Free;
  end;

  // Compute the average of valid Mag values and write it to the top of column 10
  if validMagCount > 0 then
  begin
//    sgData.Cells[10, 0] := FormatFloat('0.00', validMagSum / validMagCount);
    frmMain.ledMagnitude.Text := FormatFloat('0.00', validMagSum / validMagCount);
  end;
end;


function Remaining_PS: Boolean;
begin
  Result := (StrToInt(frmMain.edtUsed_P.Text) >= 3) and (StrToInt(frmMain.edtUsed_S.Text) >= 1);
end;

function CheckValuesAndAddAsterisk_S(RMS_limit: Double): Boolean;
var
  i: Integer;
  value: Double;
  found: Boolean;
begin
  found := False;
  for i := 1 to frmMain.sgMainData.RowCount - 1 do
  begin
    if frmMain.sgMainData.Cells[0, i] = '' then break;
    value := Abs(StrToFloatDef(frmMain.sgMainData.Cells[5, i], -1)); // Read value

    if (value >= RMS_limit) and (Trim(frmMain.sgMainData.Cells[6, i]) = '') then begin
      frmMain.sgMainData.Cells[6, i] := '*'; // Add *
      found := True;
    end
    else
//      frmMain.sgMainData.Cells[6, i] := ''; // Clear column 6 if value is less than RMS_limit
  end;
  Result := found;
end;

function CheckValuesAndAddAsterisk_P(RMS_limit: Double): Boolean;
var
  i: Integer;
  value: Double;
  found: Boolean;
begin
  found := False;
  for i := 1 to frmMain.sgMainData.RowCount - 1 do
  begin
    if frmMain.sgMainData.Cells[0, i] = '' then break;
    value := Abs(StrToFloatDef(frmMain.sgMainData.Cells[2, i], -1)); // Read value from

    if (value >= RMS_limit) and (Trim(frmMain.sgMainData.Cells[3, i]) = '') then begin
      frmMain.sgMainData.Cells[3, i] := '*'; // Add * to
      found := True;
    end
    else
//      frmMain.sgMainData.Cells[6, i] := ''; // Clear column 6 if value is less than RMS_limit
  end;
  Result := found;
end;
//-----------------
function Highest_PS(P_S: Char) : Integer;
var
  i, highestValueRow: Integer;
  highestValue, currentValue: Double;
  columnValue, columnMarker: Integer;
  ctr: Integer;
begin
  Result := -1; // Default return value indicating no row found.
  // Assign column numbers based on the data type.
  if P_S = 'P' then
  begin
    columnValue := 2;
    columnMarker := 3;
  end
  else // Assume 'S'
  begin
    columnValue := 5;
    columnMarker := 6;
  end;
  // Exit if there is no data to process.
  if frmMain.sgMainData.RowCount < 2 then
    Exit;
  // Initialize the highest value as 0 and the highest value row as 1.
  highestValue := 0.0;
  highestValueRow := 1;
  // Get the row count and iterate through the rows of the grid.
  ctr := frmMain.sgMainData.RowCount;
  for i := 1 to ctr - 1 do
  begin
    // Continue to the next iteration if the current cell in the marker column has an asterisk.
    if (frmMain.sgMainData.Cells[columnMarker, i]  = '*') then continue;
    // Get the absolute value of the current cell in the value column, using the highest value as a default.
    currentValue := Abs(StrToFloatDef(frmMain.sgMainData.Cells[columnValue, i], highestValue ));
    // Check if the current value is greater than the highest value found so far.
    if currentValue > highestValue then
    begin
      // If so, update the highest value and the highest value row.
      highestValue := currentValue;
      highestValueRow := i;
    end;
  end;
  // Return the row number of the highest value only if the highest value is greater than or equal to 1.
  if highestValue >= 1 then
    Result := highestValueRow
  else
    Result := -1; // Return -1 if the highest value is less than 1.
end;

end.